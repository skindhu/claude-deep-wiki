"""
Semantic Prompt Builder - 语义分析提示词构建器

负责构建所有与语义分析相关的提示词
"""

import json
from typing import Dict, Any, List


class SemanticPromptBuilder:
    """语义分析提示词构建器"""

    @staticmethod
    def build_batch_analysis_prompt(
        module_name: str,
        description: str,
        repo_path: str,
        files: List[str],
        batch_idx: int = None,
        total_batches: int = None
    ) -> str:
        """
        构建批次分析提示词

        Args:
            module_name: 模块名称
            description: 模块描述/职责
            repo_path: 仓库路径
            files: 需要分析的文件路径列表
            batch_idx: 当前批次索引（可选）
            total_batches: 总批次数（可选）

        Returns:
            提示词字符串
        """
        # 批次上下文说明
        batch_context = ""
        if total_batches and total_batches > 1:
            batch_context = f"""
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📦 批次信息
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**当前批次**: 第 {batch_idx}/{total_batches} 批

⚠️ 重要提示：
- 这是批量分析的一部分，请保持分析风格的一致性
- 与其他批次的文件可能存在关联，请在必要时说明
- 专注于当前批次的文件，不要臆测其他批次的内容
"""

        return f"""你是资深的业务逻辑分析专家。你的核心任务是**深入理解代码背后的业务逻辑实现**。

⚠️⚠️⚠️ 【输出格式要求】 ⚠️⚠️⚠️

**你的输出必须使用以下格式：**

✅ 正确格式（使用markdown代码块）：
```json
{{
  "files_analysis": [
    ...
  ]
}}
```

❌ 禁止：
- 在代码块前后添加过多解释（简短说明可以接受）
- 输出多个JSON代码块
- JSON格式错误或不完整

{batch_context}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📋 阶段2 任务：深度业务逻辑分析
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**🎯 核心目标**: 不是简单描述代码做了什么，而是深入解释**为什么这样做、业务上如何运作、对用户有什么影响**。

**模块信息**:
- 模块名称: {module_name}
- 模块职责: {description}
- 仓库路径: {repo_path}

**本批次需要分析的文件** ({len(files)} 个):
{json.dumps(files, ensure_ascii=False, indent=2)}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📝 深度分析任务（对每个文件）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

**对每个文件执行以下深度分析**:

1. **【可选】使用 analyze_code_block 工具快速了解文件结构**:
   - 目的：快速获取文件包含哪些函数和类的概览
   - 限制：工具只提供名称和参数列表，不包含业务逻辑实现
   - 参数: code=文件内容, language=编程语言, context={{module: "{module_name}"}}

2. **【必需】完整阅读代码文件**:
   - 使用 read_file 工具读取完整代码内容
   - 仔细阅读每个函数的详细实现
   - 追踪数据流和业务逻辑执行路径
   - **不能只依赖工具输出**，必须理解代码细节

3. **深入分析业务逻辑实现**:
   - **业务目的**: 这个函数解决什么业务问题？为什么需要它？
   - **输入参数**: 每个参数的业务含义、取值范围、业务约束
   - **输出结果**: 返回值的业务含义、对业务流程的影响
   - **详细业务逻辑**:
     * 完整的业务处理步骤（尽可能详细，不限制步数）
     * 每一步的业务含义和为什么这样做
     * 关键的业务决策点（if/switch）及决策依据
     * 循环处理的业务场景（为什么需要遍历）
     * 数据转换的业务意义（为什么这样转换）
   - **业务规则与约束**:
     * 业务验证规则（如：金额必须>0）
     * 业务流程约束（如：必须先登录才能下单）
     * 权限控制逻辑
   - **异常与边界情况**:
     * 各种异常的业务含义
     * 边界值的业务处理
     * 降级方案和补偿机制
   - **业务影响**:
     * 对用户体验的影响
     * 对数据状态的改变
     * 对其他业务流程的连锁影响

3. **使用业务语言描述实现细节**:
   - ❌ 错误: "该函数调用了 getUserById 方法"
   - ✅ 正确: "系统首先验证用户ID的合法性，然后从数据库获取用户详细信息，包括基本资料、权限级别和账户状态，最后根据用户的会员等级决定返回的数据范围"
   - ❌ 错误: "循环遍历订单列表"
   - ✅ 正确: "逐个检查用户的历史订单，筛选出30天内的有效订单，计算总消费金额以判断是否达到升级VIP的条件"

4. **业务逻辑深度分析示例**:

   示例函数: `processOrder(orderId, userId)`

   ❌ **浅层分析**（避免）:
   ```
   这个函数处理订单，接收订单ID和用户ID，返回处理结果。
   步骤：
   1. 获取订单
   2. 验证用户
   3. 处理订单
   4. 返回结果
   ```

   ✅ **深度业务逻辑分析**（目标）:
   ```
   业务目的: 处理用户提交的订单，完成从订单验证到支付确认的完整业务流程

   详细业务逻辑:
   1. [数据获取] 根据订单ID从数据库获取订单详情
      - 业务原因: 需要完整的订单信息才能进行后续处理
      - 决策点: 如果订单不存在，返回"订单未找到"错误
      - 业务规则: 只能处理状态为"待支付"的订单

   2. [权限验证] 验证用户是否有权限操作此订单
      - 业务原因: 防止用户操作他人的订单，保护交易安全
      - 决策点: 如果订单归属用户ID与当前用户ID不匹配，拒绝操作
      - 业务影响: 保护用户隐私和财产安全

   3. [库存检查] 检查订单中所有商品的库存
      - 业务原因: 确保有足够库存完成交易，避免超卖
      - 决策点: 如果任一商品库存不足，标记该商品并询问用户是否继续
      - 业务规则: 库存检查必须是原子操作，防止并发问题

   4. [价格计算] 重新计算订单总价
      - 业务原因: 防止价格篡改，使用最新的商品价格和优惠信息
      - 业务规则:
         * 应用用户的会员折扣
         * 应用优惠券（如果有）
         * 计算运费（根据配送地址）
      - 决策点: 如果计算的价格与订单价格差异>1%，提示用户价格变动

   5. [支付处理] 调用支付网关完成支付
      - 业务原因: 收取用户款项，完成交易闭环
      - 异常处理:
         * 余额不足: 提示用户充值或使用其他支付方式
         * 支付超时: 保留订单15分钟，允许重试
         * 网络异常: 进入待确认状态，通过回调确认支付结果

   6. [库存扣减] 扣减商品库存
      - 业务原因: 支付成功后需要预留商品，防止其他用户购买
      - 业务规则: 使用分布式锁确保库存扣减的准确性
      - 补偿机制: 如果后续步骤失败，需要回滚库存

   7. [订单状态更新] 将订单状态从"待支付"改为"已支付"
      - 业务原因: 标记订单已完成支付，触发后续的发货流程
      - 业务影响:
         * 仓库系统会接收到拣货任务
         * 用户会收到支付成功通知
         * 积分系统会增加用户积分

   8. [通知发送] 发送支付成功通知给用户
      - 业务原因: 告知用户支付结果，提升用户体验
      - 通知渠道: 站内信、邮件、短信（根据用户设置）
      - 异常处理: 通知失败不影响订单流程，会异步重试
   ```

⚠️ 重要约束:
- **必须完整阅读代码**，理解详细的业务逻辑实现
- **基于真实代码**，不得编造函数或功能
- **严格遵循代码逻辑**，不推测不确定的内容
- **使用产品语言表达**，避免技术术语
- 如果文件过大或分析失败，跳过该文件并记录

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
📤 输出格式规范
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

请使用以下格式输出（用```json包裹）：

```json
{{
  "files_analysis": [
    {{
      "file_path": "...",
      "business_function": "用产品语言描述：这个文件为用户提供什么功能",
      "core_logic": "详细描述代码的执行流程和具体逻辑（尽可能详细，不限步数）",
      "data_flow": "数据从哪里来，如何处理，最后到哪里去",
      "classes": [
        {{
          "name": "类名",
          "purpose": "用产品语言描述这个类负责什么功能",
          "key_methods": [
            {{
              "name": "方法名",
              "purpose": "这个方法做什么",
              "business_logic": "详细的业务逻辑步骤"
            }}
          ]
        }}
      ],
      "functions": [
        {{
          "name": "函数名",
          "purpose": "用产品语言描述这个函数负责什么功能",
          "business_logic": "详细的业务逻辑步骤（参考上面processOrder的示例）",
          "input_params": "参数的业务含义",
          "output": "返回值的业务含义",
          "business_rules": ["业务规则1", "业务规则2"],
          "edge_cases": "边界情况处理"
        }}
      ]
    }}
  ]
}}
```

**输出要求**：
- 必须分析每个文件，不要遗漏
- 使用产品语言和业务语言，面向产品经理和用户
- 严格基于代码逻辑，不推测
- core_logic 和 business_logic 字段必须尽可能详细，不限制步数（参考上面processOrder示例的详细描述风格）
- 可以在代码块前简短说明分析思路，但保持简洁
- 使用```json包裹JSON内容
- 确保JSON格式完全正确，可被json.loads()解析
- 不要输出多个JSON代码块
"""

